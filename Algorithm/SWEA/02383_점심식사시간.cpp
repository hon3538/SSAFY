#include <iostream>
using namespace std;
//계단에서 출발해서 bfs 돌리면서 사람을 찾아나간다.
//사람을 발견하면 해당 사람과의 거리 + 계단 길이 => 그 사람이 완전히 계단을 내려가기까지 시간 이 된다
//사람을 찾을 때마다 queue에 해당 사람이 다 내려갈 시간을 넣어준다
//시간이 지날때마다 q를 확인하며 다 내려간 사람은 pop해준다
//만약 3명이 꽉찼을때 새로운 사람이 들어오려한다면, 가장 먼저 나갈 사람의 시간을 확인하고 현재 시간과 차이만큼
//들어올 사람의 시간에 추가해주고 넣어주고 가장먼저나갈 사람은 pop해준다.

//다른 계단에서도 반복한다. 사람을 발견할때마다 해당 위치에 있는 시간보다 적을경우 업데이트해준다.
//근데 이러면 계단에 가까운 사람우선으로 넣어서 겹칠 경우 사람을 효율적으로 분배할 방법이 안 보이네...

//DFS로 level을 사람으로 하고 branch는 1번계단, 2번계단 으로 한다.
//계단 별로 queue를 만들어서 위 논리를 반복한다면? -> 안 돼...거리 상관없이 먼저 queue에 넣어버림..

//그럼 dfs로 하고 마지막 레벨에서 계단 bfs 를 하면? 2^10 *100*2 => 최대 20만 ? 굳


int N;

int main(){
    int T;
    cin>>T;
    for(int t=0;t<T;t++){
        cin>>N;
        for(int y=0;y<N;y++){
            for(int x=0;x<N;x++){

            }
        }

    }

    return 0;
}