//DP - 푸는 방법이 2개
//#1 Top-Down **정석적인 방법
//=> 재귀 형태
//=> N번노드의 문제에서 시작해서 풀 수 있는 문제가 나올때까지 
// 하위 문제들로 점점내려간다 (memorization-fibonachi)  

//#2 Bottom-Up **점화식이 중요
//=> 우리가 풀 수 있는 가장 작은 문제부터 시작(fibonachi에서는 1번과 2번부터 시작..)
// 이 작은 문제들의 결과를 이용하여 그 상위 문제들을 푼다. (Tabulation)

/* 두 가지 방법의 특징

#1 Momorization (Top-Down)
- 정석적인 방법 (재귀 동작에 대한 이해도가 있다)
- 초기에 이 방법이 설계하기 더 쉽다
- 가지치기, backtracking, return 조건만 생각하고 구성
- 조건이 까다로워도 설계는 생각보다 어렵지 않다
- 재귀 호출 + return 취합 -> Tabulation보다 비교적 느림
- 모든 문제를 풀지 않음 (내가 풀어야 하는 문제만 푼다)

#2 Tabulation (Bottom-Up)
- 점화식 구성이 필요하므로 상대적으로 어렵다
- 점화식 구성에 조건이 까다로우면 점화식 만들기도 쉽지 않다.
- 최하위 문제로부터 N까지 필요여부와 상관없이 모든 문제를 풀고 DP에 저장해둔다.

=> 따라서 문제에 따라서 더 효율적인 방법이 있을 순 있지만 비슷하다.
*/
#include <iostream>
using namespace std;
int dp[101];
int main(){
    int N;
    cin>>N;
    
    //Bottom-Up (Tabulation)
    //아래의(가장 하위의 문제)부터 순차적으로 더 상위 문제를 해결한다
    // * 점화식을 생성할 수 있어야한다.
    // 가장 작은 문제에 대한 해답을 구해야 한다
    dp[1]=1;
    dp[2]=1; // 가장 작은 문제에 대한 답을 알고 있는 상태다
    for(int i=3;i<=N;i++){
        dp[i]=dp[i-2]+dp[i-1];
    }
    cout <<dp[N];
}