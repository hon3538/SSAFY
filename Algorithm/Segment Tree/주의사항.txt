segment tree는 구간이 고정되어 있을 때 사용가능하며
값이 수정될 때 특정 구간의 하나의 요소가 수정되면 update 구현이 가능하다.

하지만 요소가 아닌 구간의 데이터 자체가 수정되면 찾기 어렵다.
ex) 이미 예약된 체크인 체크아웃 과 안 겹치게 예약하는 것을 segtree로 구현하려면
예약될 때마다 체크인~체크아웃 날짜 구간에 예약 했음을 표시해줘야한다.

void st_add(int start, int end, int from, int to, int index, int id) {
    if (start > to || end < from) return;
    //겹치는 구간은 다 안돼 
    if (segment[index].find(id) == segment[index].end()) {
           segment[index].insert(id);
     }

    if (start == end) return;

    int mid = (start + end) / 2;
    st_add(start, mid, from, to, index * 2, id);
    st_add(mid + 1, end, from, to, index * 2 + 1, id);
}

구간을 업데이트 할때, 해당 구간에 포함되는 모든 구간을 업데이트 해야해서 비효율적이다
ex) 1~100만날짜가 있을때, 1~10만날짜를 예약했다하면
1~5만 5~10만 1~2.5만 2.5~5만 5~7.5만 7.5~10만 1~1.25만...의 모든 구간에 예약정보를 업데이트해줘야한다

왜냐하면 1~10만날짜에 포함되는 1~5만, 5~10만만 표기해준다?
그럼 다음 사람이 2~3만에 예약가능한지 묻는다면 
2~3만에 1~5만은 포함되지 않으므로 1~2.5, 2.5~5, 1~1.25, 1.25~2.5,...
이런식으로 타고 내려갈 것이다. 하지만 1~5만과 5~10만에만 예약정보를 담았으므로
그 아래 노드로 갈 경우에 해당 날짜구간에 예약이 됐는지 확인할 수 없다.



다른 방식으로 구간을 겹치는지 여부로만 판단한다면
위예시를 봤을 때 1~10만에 사람이 예약했을때
1~10만이 포함하는 구간에만 예약정보를 담고 리턴한다.

find할때는 탐색하면서 겹치면 리턴한다.
하지만 11만~100만에 예약하고 싶은지 알고싶으면
역시 거의 모든 구간정보를 확인해야한다
1~100만, 1~50만, 50~100만, 1~25만, ....,1~6.5만 <-여기엔 체크가 돼있을 것이다.
하지만 50~100만, 50~75만, 75~100만, 50~62.5만 ... start==end 일때까지 모든 구간정보를
보게되면 탐색마다 NlogN을 소요한다... 개손해

따라서 구간 단위로 정보의 수정/추가할때는 어떻게든 사용될 수 없다.

결론적으로 구간의 크기가 고정이고 특정 구간의 특정 요소가 수정될때!만 사용가능하다
또는 구간의 크기가 고정이고 수정/추가 없이 구간 정보만을 활용할때도 사용가능하다.

